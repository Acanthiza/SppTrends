---
title: "Data driven definition of South Australian ecosystems"
author:
- Department for Environment and Water
date: "`r format(Sys.time(), '%A, %d %B, %Y')`"
output:
  bookdown::gitbook:
    split_by: chapter
    toc_depth: 4
    keep_md: no
    fig_caption: TRUE
csl:                          "common/BibStyle.csl"
bibliography:                 ["common/refs.bib","common/packageCitations.bib"]
link-citations: yes
editor_options: 
  chunk_output_type: console
---

# Setup code

```{r setup, code = readLines("0010_setup.R"), echo = TRUE, warning = FALSE, message = FALSE}
```


```{r data}

  classCombo <- tribble(
    ~Class, ~useClass, ~useClassText
    , "Amphibia", "Notbirds", "Mammals, reptiles and amphibians"
    , "Aves", "Birds", "Birds"
    , "Mammalia", "Notbirds", "Mammals, reptiles and amphibians"
    , "Reptilia", "Notbirds", "Mammals, reptiles and amphibians"
    , "Actinopterygii", "Fish", "Fish"
  )

```

# Taxa data

## BDBSA

```{r bdbsa}

  # Save to
  saveTo <- paste0(dirname(outDir),"/bdbsa")
  dir_create(saveTo)

  if(bdbsa){
    
    source("code/bdbsa.r")
    
  } else {
    
    dir_ls(saveTo) %>%
      purrr::map(read_rds) %>%
      setNames(gsub(".rds","",path_file(names(.)))) %>%
      purrr::walk2(names(.)
                   ,.
                   ,~assign(x = .x, value = .y, envir = .GlobalEnv)
                  )
    
  }

```



## Results

```{r taxaAll}

  outFile <- paste0(outDir,"/taxaAll.rds")

  if(file.exists(outFile)) {
    
    taxaAll <- read_rds(outFile)
    
  } else {

    taxaAll <- ls(pattern = "taxa.+All$") %>%
      enframe(name = NULL, value = "objects") %>%
      dplyr::mutate(data = map(objects,get)) %>%
      tidyr::unnest() %>%
      dplyr::filter(!grepl(" another species|Not naturalised in SA|Unidentified|unverified",SPECIES)) %>%
      dplyr::mutate(SPECIES = gsub("\\s"," ",SPECIES))
  
    write_rds(taxaAll
              , outFile
              )
    
  }

```

```{r patchesAll}

  r <- raster(extent(polys)
                , resolution = gridSize
                , crs = st_crs(polys)[[2]]
                , vals = 1
                )

  rPoly <- r %>%
    as('SpatialPolygonsDataFrame') %>%
    st_as_sf() %>%
    tibble::rowid_to_column(var = "Cell")

  outFile <- paste0(outDir,"/patchesAll.rds")

  if(file.exists(outFile)) {
    
    patchesAll <- read_rds(outFile)
    
  } else {
    
    patchesAll <- ls(pattern = "patches.+All$") %>%
      enframe(name = NULL, value = "objects") %>%
      dplyr::mutate(data = map(objects,get)) %>%
      tidyr::unnest() %>%
      st_as_sf(coords = c("LONGITUDE","LATITUDE")
               , crs = 4283
               , remove = FALSE # keep the Lat and Long fields even when they're turned into coordinates
               ) %>%
      st_transform(crs = st_crs(polys)) %>%
      st_join(polys
              , join = st_intersects
              ) %>%
      st_join(ibraSub
              , join = st_intersects
              ) %>%
      st_join(rPoly
              , join = st_intersects
              ) %>%
      dplyr::select(grep("SHAPE|OBJECTID",names(.),invert = TRUE))
    
      write_rds(patchesAll
                , outFile
                )

  }
  
```

# Taxonomy

The following steps were taken to generate the single taxonomy:

* BDBSA taxa were queried against the global biodiversity information facility (GBIF) [taxonomy backbone](https://www.gbif.org/dataset/d7dddbf4-2cf0-4f39-9b2a-bb099caae36c)
* any of the resulting taxa identified to a taxonomic level above species were removed
* all of the resulting taxa were grouped to species level (e.g. any records of _Barnardius zonarius zonarius_ were changed to _Barnardius zonarius_)

## GBIF taxa

```{r luGBIF}

  taxaAll %>%
    dplyr::count(SPECIES,NSXCODE) %>%
    dplyr::select(SPECIES,id = NSXCODE) %>%
    unique() %>%
    #dplyr::sample_n(30) %>% # FOR TESTING ONLY
    gbif_tax(1,2,"data/luGBIF.csv","Animalia")

  luGBIF <- read_csv("data/luGBIF.csv") %>%
    dplyr::mutate(TaxaGBIF = Taxa
                  , Rank = str_to_sentence(Rank)
                  , Rank = gsub("Division","Phylum",Rank)
                  , Rank = fct_expand(Rank,"Class","Order")
                  , Rank = fct_relevel(Rank,"Kingdom","Phylum","Class","Order"
                                      ,"Family","Genus","Species","Subspecies","Variety","Form"
                                      )
                  )
  
  luInd <- taxaBDBSAAll %>%
    dplyr::left_join(luGBIF, by = c("NSXCODE" = "id")) %>%
    dplyr::count(Taxa,ISINDIGENOUSFLAG) %>%
    dplyr::mutate(ISINDIGENOUS = if_else(is.na(ISINDIGENOUSFLAG),"Y","N")) %>%
    dplyr::filter(!is.na(Taxa)) %>%
    dplyr::group_by(Taxa) %>%
    dplyr::filter(n == max(n, na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    dplyr::select(Taxa,ISINDIGENOUS)
  
  luTax <- luGBIF %>%
    dplyr::left_join(luInd) %>%
    dplyr::select(originalName,TaxaGBIF,Taxa,everything())
  
  luTaxSimple <- luTax %>%
    dplyr::count(key,Taxa,Kingdom,Phylum,Class,Order,Family,Genus,Species,ISINDIGENOUS) %>%
    dplyr::select(-n)
  
  temp <- luTaxSimple %>%
    dplyr::filter(!is.na(Species)) %>%
    dplyr::sample_n(10) %>%
    dplyr::mutate(common = map2(key, Taxa, name_usage, language = "ENGLISH", data="vernacularNames")
                  , filter = map_lgl(common, ~nrow(.$data) > 0)
                  ) %>%
    dplyr::filter(filter) %>%
    dplyr::mutate(common = map_chr(common
                                     , function(x) x[[2]] %>%
                                       dplyr::filter(language == "eng") %>%
                                       dplyr::count(vernacularName) %>%
                                       dplyr::slice(1) %>%
                                       dplyr::pull(vernacularName)
                                     )
                  )
  
  write_rds(luTax,paste0(outDir,"/luTax.rds"))
  
```

The `r n_distinct(luGBIF$originalName)` original taxa were queried against GBIF [taxonomy backbone](https://www.gbif.org/dataset/d7dddbf4-2cf0-4f39-9b2a-bb099caae36c). This resulted in the original taxa being matched to `r n_distinct(luGBIF$TaxaGBIF)` taxa based on direct matches and enabled a further reduction to `r n_distinct(luTax$Taxa)` taxa by reducing all higher resolution taxa to species (binomial) level. Table \@ref(tab:taxHier) summarises the number of taxa identified to each level of the taxonomic hierarchy.

Table \@ref(tab:changesGBIF) shows the resulting taxonomy where more than one of the lumped taxa is represented by a single GBIF taxa.

---

```{r taxHier}

  kable(taxaAll %>%
          dplyr::left_join(luTax, by = c("NSXCODE" = "id")) %>%
          dplyr::group_by(Rank) %>%
          dplyr::summarise(n = n_distinct(SPECIES)
                           , Records = n()
                           ) %>%
          dplyr::ungroup()
        , caption = "Count of taxa identified to various taxonomic rank"
        ) %>%
    kable_styling("striped") %>%
    scroll_box(width = "100%")

```

---

```{r changes, results = "asis"}

  cat("<table>",paste0("<caption>","(#tab:changesGBIF)","Summary of changes to taxonomy made by using GBIF taxa","</caption>"),"</table>", sep = "\n")
  
  datatable(luTax %>%
              dplyr::left_join(taxaAll %>% dplyr::count(NSXCODE), by = c("id" = "NSXCODE")) %>%
              dplyr::arrange(Taxa) %>%
              dplyr::select(`Original taxa` = originalName
                            , `Taxa to use` = Taxa
                            , Records = n
                            , Native = ISINDIGENOUS
                            )
            , filter = "top"
            , fillContainer = T
            )
  
```

# Analysis methods

A `r (gridSize/1000)^2` km^2^ grid was placed over South Australia. This grid was used to generate 'pseudo-sites' for several analyses (always within a grouping of interest). Across all analyses, a taxa needed to have been recorded in more than `r minTaxaOccurence` grids, after generation of psuedo-lists, to be included.

* reporting rate:
    + a pseudo-list was generated for:
        + grids with more than `r minRRListLength` taxa recorded, and
        + years with more than `r minListsPerYear` grids with records, and
        + taxa with records in more than `r minTaxaOccurence` grids
    + reporting rate was analysed by a binomial generalised linear mixed model. 'Success' in the response variable was the number of grid cells taxa x was recorded in for a year and 'Attempts' was the number of grid cells visited in that year. Fixed variables were year and a grouping of interest (e.g. sometimes this was taxonomic such as 'Family' or 'Order' and sometimes it was ecological, such as 'ground foraging insectivore' or 'wader'). Random variables were taxa, with the trend allowed to vary with year per taxa.
* list length analysis:
    + a pseudo-list was generated for:
        + grids with more than `r minLLListLength` taxa recorded, and
        + years with more than `r minListsPerYear` grids with records, and
        + taxa with records in more than `r minTaxaOccurence` grids
    + reporting rate was analysed by a binomial generalised linear mixed model. 'Success' in the response variable was the presence of species x on a list and 'Attempts' was the number of taxa recorded in a grid cell in that year. Fixed variables were year and a grouping of interest (e.g. sometimes this was taxonomic such as 'Family' or 'Order' and sometimes it was ecological, such as 'ground foraging insectivore' or 'wader'). Random variables were taxa, with the trend allowed to vary with year per taxa.
        
---

```{r taxaGroups}

  dat <- taxaAll %>%
    dplyr::left_join(luTax, by = c("NSXCODE" = "id")) %>%
    dplyr::mutate(rankFilt = as.numeric(Rank)) %>%
    dplyr::filter(rankFilt >= 7) %>%
    dplyr::filter(!is.na(Species)) %>%
    dplyr::mutate(Year = year(VISITDATE)) %>%
    dplyr::add_count(Class) %>%
    dplyr::filter(n > 10000) %>%
    dplyr::left_join(patchesAll %>% st_set_geometry(NULL) %>% dplyr::select(PATCHID,Cell)) %>%
    dplyr::count(Year,Taxa,Cell) %>%
    dplyr::add_count(Taxa) %>%
    dplyr::rename(Cells = n) %>%
    dplyr::add_count(Year) %>%
    dplyr::rename(Years = n) %>%
    dplyr::filter(Cells > 3) %>%
    dplyr::filter(Years > 3) %>%
    dplyr::mutate(n = 1
                  , vis = paste0(Year,"_",Cell)
                  )
    
  
  datWide <- dat %>%
    dplyr::group_by(Taxa) %>%
    dplyr::slice(sample(1:n())) %>%
    dplyr::filter(row_number() < 200) %>%
    dplyr::ungroup() %>%
    dplyr::select(vis,Taxa,n) %>%
    tidyr::spread(vis,n,fill=0)
  
```

```{r datDist}
  
  outFile <- paste0(outDir,"/datDist.rds")
  
  datWideMatrix <- data.matrix(datWide[,-1], rownames.force = TRUE)
  rownames(datWideMatrix) <- datWide$Taxa
  
  datDist <- parDist(datWideMatrix
                     , method = "bray"
                     , threads = useCores
                     )
  
  possibleGroups <- 2:50

```
  
```{r hierarchical}

  hierMethods <- tribble(
    ~method, ~methodFunction
    , "single", "fastcluster"
    , "complete", "fastcluster"
    , "average", "fastcluster"
    , "mcquitty", "fastcluster"
    , "ward.D", "fastcluster"
    , "ward.D2", "fastcluster"
    , "centroid", "fastcluster"
    , "median", "fastcluster"
    )

  outFile <- paste0(outDir,"/datDend.rds")

  datDend <- hierMethods %>%
    dplyr::mutate(dend = map(method
                             ,~fastcluster::hclust(datDist, .)
                             )
                  )
  
  write_rds(datDend, outFile)
  
```

```{r silClusters}

  sil_mean <- function(clusters){
    
    silDf <- cluster::silhouette(clusters %>% dplyr::pull(clust)
                                 , datDist
                                 )
    
    mean(silDf[,3])
    
  }

  datClust <- datDend %>%
    dplyr::mutate(clusters = map(dend
                                 , cutree
                                 , possibleGroups
                                 )
                  , clusters = map(clusters, function(x) dplyr::bind_cols(datWide[,1],as_tibble(x)))
                  ) %>%
    dplyr::select(-methodFunction) %>%
    tidyr::unnest(clusters) %>%
    tidyr::gather(groups,clust,`2`:ncol(.)) %>%
    dplyr::group_by(method,groups) %>%
    tidyr::nest() %>%
    dplyr::ungroup() %>%
    dplyr::mutate(groups = as.numeric(groups) 
                  , sil = map_dbl(data,sil_mean)
                  , nTaxa = map_dbl(data,nrow)
                  , actualClusters = map_dbl(data,function(x) n_distinct(x$clust))
                  , minClustSize = map_dbl(data, function(x) min(table(x$clust)))
                  , avClustSize = map_dbl(data, function(x) mean(table(x$clust)))
                  )
  
  chooseClust <- datClust %>%
    dplyr::filter(minClustSize > 10) %>%
    dplyr::top_n(1,sil)

  chooseMethod <- chooseClust$method
  chooseGroups <- chooseClust$groups
  
```

```{r sil, fig.cap = "Silhouette width tends to increase with increasing number of groups, sometimes after an initial decrease (e.g. average and weighted)"}

  ggplot(datClust, aes(groups,sil)) +
    geom_point() +
    geom_hline(yintercept = 0, colour = "red", linetype = 2) +
    facet_wrap(~method) +
    labs(y = "silhouette width")

```

```{r clustering, fig.cap = paste0("clustering on the dendrogram produced using the ",chooseMethod," method of the fastcluster::hclust function on ",nrow(datWide), " taxa ",chooseGroups," groups (or clusters, red boxes) are shown")}

  clust <- datDend %>%
    dplyr::filter(method == chooseMethod)
  
  plot(clust$dend[[1]],cex = 0.5)

  rect.hclust(clust$dend[[1]], k = chooseGroups)

```

```{r bestGroup}

  bestGroup <- chooseClust %>%
      dplyr::mutate(silDf = purrr::map(data
                                        , function(x) cluster::silhouette(x %>% pull(clust), datDist)
                                       )
                    , silDf = purrr::map(silDf
                                          , ~tibble::as_tibble(cbind(PATCHID = datWide[,1]
                                                                     , clust=.[,1]
                                                                     , neighbor=.[,2]
                                                                     , sil_width=.[,3]
                                                                     )
                                                               )
                                          )
                    ) %>%
      tidyr::unnest(silDf) %>%
      dplyr::arrange(clust,desc(sil_width)) %>%
      dplyr::mutate(rowBest = row_number()
                    , cluster = fct_reorder(numbers2words(clust),clust)
                    , clusNeigh = if_else(sil_width>0,clust,neighbor)
                    , clusNeigh = numbers2words(clusNeigh)
                    , clusNeigh = factor(clusNeigh,levels = levels(cluster))
                    ) %>%
      dplyr::add_count(cluster)
  
    write_rds(bestGroup, paste0(outDir,"/bestGroup.rds"))
    
    # set colours
    discreteColour <- scale_colour_viridis_d(limits = levels(bestGroup$cluster))
    discreteFill <- scale_fill_viridis_d(limits = levels(bestGroup$cluster))
    
```

```{r clusters}
  
  # Summarise cluster
  clusters <- bestGroup %>%
    dplyr::group_by(clust,cluster) %>%
    dplyr::left_join(luTaxSimple) %>%
    dplyr::summarise(nPatchesFlor = n()
                     , meanSil = mean(sil_width)
                     , midRow = mean(rowBest)
                     , nClust = sum(sil_width>0)
                     , nNotClust = sum(sil_width<=0)
                     , y = min(bestGroup$sil_width,na.rm = TRUE)
                     , propPos = nClust/nPatchesFlor
                     , Aves = sum(Class == "Aves")
                     , Mammalia = sum(Class == "Mammalia")
                     , Reptilia = sum(Class == "Reptilia")
                     , Amphibia = sum(Class == "Amphibia")
                     , Fish = sum(Class == "Actinopterygii")
                     ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(cluster = fct_reorder(cluster,clust)
                  , labelPatches = paste0(cluster,": n = ",nPatchesFlor)
                  , perNeigh = 100*(nNotClust/nPatchesFlor)
                  )
  
  write_rds(clusters, paste0(outDir,"/clusters.rds"))
  
```

```{r clustSilhouette, fig.height=9, fig.cap = paste0("Strength of clusters based on silhouette width. The weakest cluster was ",clusters %>% dplyr::top_n(-1,meanSil) %>% pull(cluster)," with mean silhouette width of ", clusters %>% dplyr::top_n(-1,meanSil) %>% pull(meanSil) %>% round(2), " and ", clusters %>% dplyr::top_n(-1,meanSil) %>% pull(nNotClust), " sites (",clusters %>% dplyr::top_n(-1,meanSil) %>% pull(perNeigh) %>% round(0),"%) that were actually closer to another cluster")}

  ggplot() +
    geom_col(data=bestGroup
             ,aes(rowBest
                  ,sil_width
                  ,fill=clusNeigh
                  ,color=clusNeigh
                  )
             ) +
    geom_label_repel(data=clusters# %>% dplyr::inner_join(tibble(cluster = levels(factor(bestGroup$cluster))))
                     , aes(midRow
                           ,0
                           ,label=labelPatches
                           ,fill=cluster
                           )
                     , nudge_y = min(clusters$y,na.rm=TRUE)
                     ) +
    geom_point() +
    coord_flip() +
    labs(subtitle = paste0("Negative silhouette widths are coloured by neighbouring cluster\nn = ", sum(clustersFlorSummary$nPatchesFlor), " Taxa")
         , y = "Silhouette width"
         ) +
    scale_x_reverse() +
    theme(axis.text.y=element_blank()
          , axis.title.y=element_blank()
          , axis.ticks.y=element_blank()
          , legend.position = "none"
          ) +
    discreteColour +
    discreteFill

```

```{r taxaClustSummary}

  taxaClustSummary <- bestGroup %>%
    dplyr::select(Taxa,clust,cluster) %>%
    dplyr::left_join(luTaxSimple)
  
  datatable(taxaClustSummary, filter = "top")

```

```{r datPrep}
  
  locations <- visits %>%
    dplyr::count(Taxa,Cell) %>%
    dplyr::select(-n)
  
  loopThru <- na.omit(unique(presences$Class))

```

# Analysis

```{r include=FALSE}

  src <- lapply(loopThru
                , function(thisGroup) knit_expand(file = "child/Analysis.Rmd")
                )

```

`r knit(text = unlist(src))`


<!--chapter:end:0030_report.Rmd-->


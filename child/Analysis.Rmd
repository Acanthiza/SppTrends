```{r data{{thisGroup}}}

  thisGroup <- "{{thisGroup}}"

  thisUseClass <- classCombo %>%
    dplyr::filter(Class == thisGroup) %>%
    dplyr::pull(useClass)

```

## `r thisGroup`

### Trend

```{r dataTrend{{thisGroup}}}

  # TREND FILTERING
  # loosely based on http://www.possinghamlab.org/images/LLA/LLA_and_Liszt_package_Guide.pdf
  # List length
  listLengthFilt <- lists %>%
    dplyr::filter(useClass == thisUseClass) %>%
    dplyr::filter(listLength > minRRListLength)
  
  # List per year
  listsPerYearFilt <- listLengthFilt %>%
    dplyr::count(Year,useClass,IBRA_SUB_C,Cell) %>%
    dplyr::count(Year,useClass,IBRA_SUB_C) %>%
    dplyr::rename(listsPerYear = n) %>%
    dplyr::filter(listsPerYear > 3)
  
  # Taxa occurence
  taxaOccurenceFilt <- presences %>%
    dplyr::inner_join(listLengthFilt) %>%
    dplyr::inner_join(listsPerYearFilt) %>%
    dplyr::count(Year,useClass,Class,Order,Taxa) %>%
    dplyr::count(useClass,Class,Order,Taxa) %>%
    dplyr::rename(taxaOccurence = n) %>%
    dplyr::filter(taxaOccurence > minTaxaOccurence)
  
  # Taxa location
  taxaLocation <- locations %>%
    dplyr::left_join(presences) %>%
    dplyr::count(IBRA_SUB_C,Taxa) %>%
    dplyr::inner_join(locations)
  
  # Apply filters - Trend
  datTrend <- lists %>%
    dplyr::inner_join(listLengthFilt) %>%
    dplyr::inner_join(listsPerYearFilt) %>%
    dplyr::left_join(presences) %>%
    dplyr::inner_join(taxaLocationFilt) %>%
    dplyr::inner_join(taxaOccurenceFilt) %>%
    dplyr::group_by(Year,Taxa,IBRA_SUB_C,listsPerYear,taxaOccurence) %>%
    dplyr::summarise(meanLL = mean(listLength)
                     , Records = sum(Records > 0, na.rm=TRUE)
                     ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(prop = Records/listsPerYear) %>%
    dplyr::left_join(luTaxSimple)

  datTrendGroup <- datTrend %>%
    dplyr::filter(Class == thisGroup)

```

#### Data exploration

```{r trendModPrep{{thisGroup}}}

  Y <- "prop"
  
  # variables to explore
  varExp <- c(get("Y")
              , colnames(datTrendGroup)
              ) %>%
    unique() %>%
    grep(pattern = "medYear",invert = TRUE, value=TRUE)
  
  datExp <- datTrendGroup %>%
    dplyr::select(varExp)
    
```

```{r trendMissing{{thisGroup}}, fig.cap = "Missing data"}
  
  #  Missing values
  plot_missing(datExp)

```

---

```{r trendCountDiscrete{{thisGroup}}, fig.cap = paste0("Count at each level within discrete variables (where levels < ",maxLevels,")")}
    
# Count discrete variables
  ggplot(datExp %>%
           dplyr::mutate_if(is.factor,as.character) %>%
           dplyr::select_if(is.character) %>%
           tidyr::gather(variable,value,1:ncol(.)) %>%
           dplyr::group_by(variable) %>%
           dplyr::mutate(levels = n_distinct(value)) %>%
           dplyr::ungroup() %>%
           dplyr::filter(levels < maxLevels)
         ) +
    geom_histogram(aes(value),stat="count") +
    facet_wrap(~variable, scales = "free") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```

---

```{r trendCountContinuous{{thisGroup}}, fig.cap = "Distribution of values within continuous variables"}
    
  # Count continuous variables
  ggplot(datExp %>%
           dplyr::select_if(is.numeric) %>%
           tidyr::gather(variable,value,1:ncol(.))
         , aes(value)
         ) +
    geom_histogram() +
    facet_wrap(~variable, scales = "free")

```

---

```{r trendYvsDiscrte{{thisGroup}}, fig.height = 9, fig.cap = paste0(str_to_sentence(Y), " against discrete variables")}

  # Y vs. Discrete
  ggplot(datExp %>%
           dplyr::mutate(UQ(rlang::sym(Y)) := factor(!!ensym(Y))) %>%
           dplyr::mutate_if(is.factor,as.character) %>%
           dplyr::select_if(is.character) %>%
           dplyr::mutate(UQ(rlang::sym(Y)) := as.numeric(!!ensym(Y))) %>%
           tidyr::gather(variable,value,2:ncol(.))
         ) +
    geom_boxplot(aes(value,!!ensym(Y))) +
    facet_wrap(~variable, scales = "free") +
    theme(axis.text.x=element_text(angle=90, vjust=0.5))

```

---

```{r trendYvsNumeric{{thisGroup}}, fig.height = 7, fig.cap = paste0(str_to_sentence(Y), " against continuous variables")}
    
# Y vs. Numeric
  ggplot(datExp %>%
           dplyr::select(varExp) %>%
           dplyr::select_if(is.numeric) %>%
           tidyr::gather(variable,value,2:ncol(.)) %>%
           dplyr::arrange(!!ensym(Y))
         , aes(value,!!ensym(Y))
         ) +
    geom_point(alpha = 0.5
                , width = 0.1
                , height = 0.1
                ) +
    facet_wrap(~variable, scales = "free") +
    theme(axis.text.x=element_text(angle=90, vjust=0.5))

```

---

```{r trendCollinearity{{thisGroup}}, fig.height = 9, fig.cap = "Exploring collinearity amongst variables"}

  # Homogeneity of variance
  # check modResid - plot modResid vs. fitted values
  
  # Normally distributed
  # check distribution of modResid - they should be normally distributed
  
  # Collinearity among the covariates
  ggpairs(datExp %>%
            dplyr::select(varExp) %>%
            dplyr::select_if(function(x) length(levels(as.factor(x))) < 14|is.numeric(x))
          )

```

---

```{r trendModel{{thisGroup}}}

# variables to model
  varMod <- c(if(Y == "prop") c("Records","listsPerYear") else Y
              , "prop"
              , "Taxa"
              , "Year"
              , "listsPerYear"
              , "IBRA_SUB_C"
              )

  medYear <- round(median(unique(datExp$Year)),0)
    
  datMod <- datExp %>%
    # TESTING START
    # dplyr::inner_join(datExp %>%
    #                     dplyr::group_by(!!ensym(interest)) %>%
    #                     dplyr::count(Taxa) %>%
    #                     dplyr::slice(sample(1:nrow(.))) %>%
    #                     dplyr::filter(row_number() < 0.25*nrow(.)) %>%
    #                     dplyr::ungroup() %>%
    #                     dplyr::select(-n)
    #                   ) %>%
    # TESTING FINISH
    dplyr::select(varMod) %>%
    dplyr::mutate(time = Year - medYear)
    

#-----Model------

  # If the model has not already been run, run it and save the result to the R directory
  outFile <- paste0(outDir,"/trendMod",thisGroup,".rds")
  
  if(file.exists(outFile)){
    
    mod <- read_rds(outFile)
    
  } else {
    
    mod <-
    stan_glmer(data = datMod
               
               # Normal
               #, formula = as.formula(paste0(Y, " ~ time*",interest," + (time|Taxa)"))
               
               # Binomial
               , formula = as.formula(if_else(n_distinct(datMod$Taxa) > 1
                                              , paste0("cbind(Records,listsPerYear-Records) ~ time * Taxa + listsPerYear + (1|IBRA_SUB_C)")
                                              , paste0("cbind(Records,listsPerYear-Records) ~ time + listsPerYear + (1|IBRA_SUB_C)")
                                              )
                                      )
               , family = binomial()
               
               # Beta
               # , formula = as.formula(paste0(Y, " ~ time*",interest," + (time|Taxa)"))
               # , family = mgcv::betar()
               
               # Options
               , adapt_delta = 0.99
               , chains = doChains
               , iter = doIter
               
               )
  
    write_rds(mod, outFile)
    
  }
  
  # see https://discourse.mc-stan.org/t/rstanarm-mgcv-betar-family/2947/7
  #if(mod$family$family == "beta") class(mod) <- c(class(mod),"betareg")
  # Fixed in later package versions? Seems to be working now
  
  
#-------Prediction------
  
  modPred <- as_tibble(mod$data) %>%
    dplyr::select(time,Taxa) %>%
    unique() %>%
    dplyr::mutate(col = row.names(.)
                  , Records = 0
                  , listsPerYear = 10#median(datMod$listsPerYear, na.rm = TRUE)
                  , join = 1
                  ) %>%
    # dplyr::left_join(tibble(meanLL = seq(min(datMod$meanLL)
    #                                      ,max(datMod$meanLL)
    #                                      ,(max(datMod$meanLL) - min(datMod$meanLL))/5
    #                                      )
    #                         , join = 1
    #                         )
    #                  ) %>%
    dplyr::left_join(as_tibble(posterior_predict(mod
                                                 , newdata = .
                                                 , re.form = NA
                                                 )
                               ) %>%
                       tibble::rownames_to_column(var = "row") %>%
                       tidyr::gather(col,value,2:ncol(.))
                     ) %>%
    (function(x) dplyr::bind_cols(x %>% dplyr::select(-value),value = as.numeric(x$value))) %>%
    dplyr::mutate(Year = medYear + time
                  , value = value/listsPerYear
                  )

  # summarise the results
  modRes <- modPred %>%
    dplyr::group_by(Year,Taxa) %>%
    dplyr::summarise(n = n()
                     , nCheck = nrow(as_tibble(mod))
                     , prop = quantile(value,0.5)
                     , modMean = mean(value)
                     , modMedian = quantile(value, 0.5)
                     , modci90lo = quantile(value, 0.05)
                     , modci90up = quantile(value, 0.95)
                     , text = paste0(round(modMedian,2)," (",round(modci90lo,2)," to ",round(modci90up,2),")")
                     ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate_if(is.numeric,round,2) 
  
  
#------Residuals--------
  
  modResid <- tibble(resid = residuals(mod)) %>%
    dplyr::bind_cols(datMod)
  
#-------Difference------
  
  modDiff <- as_tibble(mod) %>%
    dplyr::mutate(row = row_number()) %>%
    dplyr::select(row, everything()) %>%
    dplyr::select_if(grepl("time|row", names(.))) %>%
    dplyr::select_if(!grepl("\\[",names(.))) %>%
    dplyr::mutate(`time:TaxaDummy` = 0) %>%
    tidyr::gather(key,value,grep(":",names(.))[1]:ncol(.)) %>%
    dplyr::mutate(parameter = str_extract(key,".*:Taxa")
                  , Taxa = str_extract(key,":Taxa.*")
                  , Taxa = gsub(":Taxa","",Taxa)
                  ) %>%
    dplyr::select(-key) %>%
    tidyr::spread(parameter,value) %>%
    tidyr::gather(parameter,value,-row,-Taxa) %>%
    dplyr::group_by(row,Taxa) %>%
    dplyr::summarise(n = n()
                  , Change = sum(value)
                  , Change = if_else(mod$family$link %in% c("logit"), exp(Change),Change)
                  ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(Taxa = if_else(Taxa == "Dummy",setdiff(unique(datMod$Taxa),unique(.$Taxa)),Taxa)) %>%
    dplyr::filter(Taxa != "Dummy") %>%
    dplyr::left_join(luTaxSimple)
  
  threshold <- if_else(mod$family$link %in% c("logit"), 1,0)

  modDiffRes <- modDiff %>%
    dplyr::group_by(Taxa) %>%
    dplyr::summarise(n = n()
                     , nCheck = nrow(as_tibble(mod))
                     , modMean = mean(Change)
                     , modMedian = quantile(Change,0.5)
                     , modci90lo = quantile(Change, 0.05)
                     , modci90up = quantile(Change, 0.95)
                     , increasing = round(100*sum(Change > threshold)/n,0)
                     , decreasing = round(100*sum(Change < threshold)/n,0)
                     , text = paste0(round(modMean,4)," (",round(modci90lo,4)," to ",round(modci90up,4),")")
                     ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate_if(is.numeric,round,4) %>%
    dplyr::left_join(luTaxSimple) %>%
    dplyr::mutate(Taxa = fct_reorder(Taxa,desc(modMedian)))
  
```

#### Diagnostics

##### MCMC evaluation

Two common checks were used to evaluate the Monte Carlo Markov-chain samples: trace plots and $\hat{R}$ values.

Figure \@ref(fig:trendModTrace{{thisGroup}}) shows trace plots for each of the `r length(dimnames(as.array(mod))$chains)` chains. Each chain should be stable and well-mixed (all chains centred around the same value) showing 'random noise' around the parameter value with no step change or trend evident.

Figure \@ref(fig:trendModRhat{{thisGroup}}) shows the $\hat{R}$ values. At convergence $\hat{R}$ is one.

---

```{r trendModTrace{{thisGroup}}, fig.cap = "Trace plots: stable, well-mixed chains indicate convergence"}

  stan_trace(mod)

```

---

```{r trendModRhat{{thisGroup}}, fig.cap = "$\\hat{R}$ values close to one indicate convergence"}

  plot(mod, "rhat_hist")

```

---

##### Model fit

Given the MCMC evaluation shows no reason for concern, assuming the model was specified adequately, the model runs should generate data similar to the observed data.

Figure \@ref(fig:trendModFit{{thisGroup}}) shows a comparison of the observed data (dark line) with a sample of 50 of the the model runs (light lines). The model runs should largely follow the shape of the observed data.

Figure \@ref(fig:trendMod2d{{thisGroup}}) shows how the mean and standard deviation of the observed data (dark dot) compares with a sample of 50 of the model runs (light dots). The model runs should be centred on the observed data.

```{r trendModFit{{thisGroup}}, fig.cap = "Random selection of model runs (light blue) and actual values (dark blue)"}
  
  # Model fit
  a <- pp_check(mod) + coord_cartesian(xlim = c(min(mod$fitted.values),quantile(mod$fitted.values,probs=0.1))) + labs(title = "min-quantile(0.1)")
  b <- pp_check(mod) + coord_cartesian(xlim = c(min(mod$fitted.values),quantile(mod$fitted.values,probs=0.5))) + labs(title = "min-quantile(0.5)")
  c <- pp_check(mod) + coord_cartesian(xlim = c(quantile(mod$fitted.values,probs=0.5),max(mod$fitted.values))) + labs(title = "quantile(0.5)-max")
  d <- pp_check(mod) + labs(title = "min-max pred")
  grid.arrange(a,b,c,d)

```

---

```{r trendMod2d{{thisGroup}}, fig.cap = "Plot of model run mean and standard deviation (light blue dots) against the actual those values from the data (dark blue dots"}

   pp_check(mod, plotfun = "stat_2d", stat = c("mean", "sd"))

```

---

##### Residuals

In regression-type models, verification of homogeneity should be done by plotting residuals vs. fitted values [@RN4330]. Figure \@ref(fig:trendModYVsResid{{thisGroup}}) shows `r Y` versus the model residuals and Figure \@ref(fig:trendModContVsResid{{thisGroup}}) shows any continuous variable versus the model residuals and Figure \@ref(fig:trendModDiscVsResid{{thisGroup}})

---

```{r trendModYVsResid{{thisGroup}}, fig.cap = paste0(Y, " vs residuals")}

  # Y vs. residuals
  ggplot(modResid, aes(!!ensym(Y),resid)) +
    geom_point(size = 2
              #, alpha=0.5
              #, position=position_jitter(width=0.3,height=0.2)
              ) +
    geom_hline(aes(yintercept = 0), linetype = 2, colour = "red") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) %>%
    scale_colour_viridis_d(end=0.9)
  
```

---

```{r trendModContVsResid{{thisGroup}}, fig.cap = "Continuous explanatory variables vs residuals"}
  
  # Time vs. residuals
  ggplot(modResid %>%
           dplyr::select_if(is.numeric) %>%
           tidyr::gather(variable,value,2:ncol(.))
         , aes(value,resid)
         ) +
    geom_point(size = 2
              #, alpha=0.5
              #, position=position_jitter(width=0.3,height=0.2)
              ) +
    geom_hline(aes(yintercept = 0), linetype = 2, colour = "red") +
    facet_wrap(~variable, scales = "free_x") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
          #, strip.text.x = element_text(angle = 90)
          ) +
    scale_colour_viridis_d()

```

---

```{r trendModDiscVsResid{{thisGroup}}, fig.cap = "Discrete explanatory variables vs residuals"}
  
  ggplot(modResid %>%
           dplyr::mutate(resid = as.character(resid)) %>%
           dplyr::mutate_if(is.factor,as.character) %>%
           dplyr::select_if(is.character) %>%
           dplyr::select(resid,everything()) %>%
           dplyr::mutate(resid = as.numeric(resid)) %>%
           tidyr::gather(variable,value,2:ncol(.))
         , aes(value,resid)
         ) +
    geom_boxplot() +
    geom_hline(aes(yintercept = 0), linetype = 2, colour = "red") +
    facet_wrap(~variable, scales = "free") +
    theme(axis.text.x=element_text(angle=90, vjust=0.5))

```

---

#### Results

Figure \@ref(fig:trendModPred{{thisGroup}}) plots the model results against the original data. Figure \@ref(fig:trendModTrend{{thisGroup}}) shows the distribution of credible values of slope for each taxa. Increasing trend is indicated by slope greater than `r if_else(mod$family$link %in% c("logit"),1,0)` while decreasing trend is indicated by slope less than `r if_else(mod$family$link %in% c("logit"),1,0)`.

Based on these results Table \@ref(tab:trendModResults{{thisGroup}}) shows the likelihood that each taxa is decreasing or increasing.

---

```{r trendModPred{{thisGroup}}, fig.height = 7, fig.cap = "Model result and 90% credible intervals (line and shading) plotted with original data points"}

  ggplot(data = datMod
               , aes(Year
                     ,!!ensym(Y)
                     )
         ) +
    geom_point(alpha = 0.3) +
    geom_line(data = modRes
              , colour = "#3366FF"
              ) +
    geom_ribbon(data = modRes
                , aes(ymin=modci90lo
                      , ymax=modci90up
                      , colour = NULL
                      )
                , alpha = 0.3
                , fill = "#3366FF"
                ) +
    facet_wrap(~Taxa) +
    theme(axis.text.x = element_text(angle=90, hjust=0)
          , strip.text.y = element_text(angle = 0)
          , legend.position = "none"
          )

```

---

```{r trendModTrend{{thisGroup}}, fig.height = 7, fig.cap = paste0("The taxa most likely to be declining according to this reporting rate analysis: ", mostDec)}

  xinter <- if_else(mod$family$link %in% c("logit"),1,0)

  mostDec <- modDiffRes %>% dplyr::filter(modMedian == min(modMedian)) %>% pull(Taxa) %>% vec_to_sentence()

  ggplot(modDiff %>%
           dplyr::mutate(Taxa = fct_reorder(Taxa,desc(Change)))
         , aes(Change,Taxa,fill = 0.5-abs(0.5-..ecdf..))
         ) +
    stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE, panel_scaling = FALSE) +
    geom_vline(aes(xintercept = xinter), colour = "red", linetype = 2) +
    scale_fill_viridis_c(name = "Probability") +
    theme(strip.text.y = element_text(angle = 0)) +
    labs(x = "Change with year"
         , subtitle = if_else(mod$family$link %in% c("logit")
                              , "Values above one indicate increasing reporting rate with time"
                              , "Value above zero indicate increasing reporting rate with time"
                              )
         )

```

---

```{r trendModResults{{thisGroup}}}

  kable(modDiffRes %>%
          dplyr::select(Taxa
                        , `Median and 90% credible estimate for change` = text
                        , `Likelihood of decreasing (%)` = decreasing
                        , `Likelihood of increasing (%)` = increasing
                        ) %>%
          dplyr::arrange(desc(Taxa))
        , caption = paste0("Likelihood of changing reporting rate. Summary for ", thisGroup)
        ) %>%
    kable_styling("striped") %>%
    scroll_box(width = "100%")

```

### List length

```{r dataListLength{{thisGroup}}}

  # LL FILTERING
  # loosely based on http://www.possinghamlab.org/images/LLA/LLA_and_Liszt_package_Guide.pdf
  # List length
  listLengthFilt <- lists %>%
    dplyr::filter(listLength > minLLListLength
                  , !is.na(IBRA_SUB_C)
                  )
  
  # List per year
  listsPerYearFilt <- listLengthFilt %>%
    dplyr::count(Year,useClass,IBRA_SUB_C,Cell) %>%
    dplyr::count(Year,useClass,IBRA_SUB_C) %>%
    dplyr::rename(listsPerYear = n) %>%
    dplyr::filter(listsPerYear > 4)
  
  # Taxa occurence
  taxaOccurenceFilt <- presences %>%
    dplyr::inner_join(listLengthFilt) %>%
    dplyr::inner_join(listsPerYearFilt) %>%
    dplyr::count(Year,useClass,Class,Order,Taxa) %>%
    dplyr::count(Taxa,useClass,Class,Order) %>%
    dplyr::rename(taxaOccurence = n) %>%
    dplyr::filter(taxaOccurence > minTaxaOccurence)
  
  # Taxa location
  taxaLocationFilt <- presences %>%
    dplyr::count(IBRA_SUB_C,Taxa) %>%
    dplyr::inner_join(locations) %>%
    dplyr::select(-n)
  
  # Apply filters - LL
  datTrend <- lists %>%
    dplyr::inner_join(listLengthFilt) %>%
    dplyr::inner_join(listsPerYearFilt) %>%
    dplyr::left_join(presences) %>%
    dplyr::inner_join(taxaLocationFilt) %>%
    dplyr::inner_join(taxaOccurenceFilt) %>%
    dplyr::group_by(Year,Taxa,IBRA_SUB_C,listsPerYear,taxaOccurence) %>%
    dplyr::summarise(meanLL = mean(listLength)
                     , Records = sum(Records > 0, na.rm=TRUE)
                     ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(prop = Records/listsPerYear) %>%
    dplyr::left_join(luTaxSimple)
  
  
  datLL <- lists %>%
    dplyr::inner_join(listLengthFilt) %>%
    dplyr::inner_join(listsPerYearFilt) %>%
    dplyr::left_join(presences) %>%
    dplyr::inner_join(taxaOccurenceFilt) %>%
    dplyr::inner_join(taxaLocationFilt) %>%
    dplyr::left_join(luTaxSimple) %>%
    dplyr::mutate(p = Records
                  , p = ifelse(is.na(p),0,p)
                  )

  datLLGroup <- datLL %>%
    dplyr::filter(Class == thisGroup)

  thisUseClass <- datLLGroup %>%
    dplyr::left_join(classCombo) %>%
    dplyr::pull(useClassText) %>%
    unique()

```

### Data exploration

```{r llModPrep{{thisGroup}}}

  Y <- "p"

  # variables to explore
  varExp <- c(get("Y")
              , colnames(datLLGroup)
              ) %>%
    unique() %>%
    grep(pattern = "medYear",invert = TRUE, value=TRUE)
  
  datExp <- datLLGroup %>%
    dplyr::select(varExp)
    
```

```{r llMissing{{thisGroup}}, fig.cap = "Missing data"}
  
  #  Missing values
  plot_missing(datExp)

```

---

```{r llCountDiscrete{{thisGroup}}, fig.cap = paste0("Count at each level within discrete variables (where < ",maxLevels,")")}
    
# Count discrete variables
  ggplot(datExp %>%
           dplyr::mutate_if(is.factor,as.character) %>%
           dplyr::select_if(is.character) %>%
           tidyr::gather(variable,value,1:ncol(.)) %>%
           dplyr::group_by(variable) %>%
           dplyr::mutate(levels = n_distinct(value)) %>%
           dplyr::ungroup() %>%
           dplyr::filter(levels < maxLevels)
         ) +
    geom_histogram(aes(value),stat="count") +
    facet_wrap(~variable, scales = "free") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```

---

```{r llCountContinuous{{thisGroup}}, fig.cap = "Distribution of values within continuous variables"}
    
  # Count continuous variables
  ggplot(datExp %>%
           dplyr::select_if(is.numeric) %>%
           tidyr::gather(variable,value,1:ncol(.)) %>%
           dplyr::filter(!variable %in% c("join"))
         , aes(value)
         ) +
    geom_histogram() +
    facet_wrap(~variable, scales = "free")

```

---

```{r llYvsDiscrte{{thisGroup}}, fig.height = 9, fig.cap = paste0(str_to_sentence(Y), " against discrete variables")}

  # Y vs. Discrete
  ggplot(datExp %>%
           dplyr::mutate(UQ(rlang::sym(Y)) := factor(!!ensym(Y))) %>%
           dplyr::mutate_if(is.factor,as.character) %>%
           dplyr::select_if(is.character) %>%
           dplyr::mutate(UQ(rlang::sym(Y)) := as.numeric(!!ensym(Y))) %>%
           tidyr::gather(variable,value,2:ncol(.))
         ) +
    geom_boxplot(aes(value,!!ensym(Y))) +
    facet_wrap(~variable, scales = "free") +
    theme(axis.text.x=element_text(angle=90, vjust=0.5))

```

---

```{r llYvsNumeric{{thisGroup}}, fig.height = 7, fig.cap = paste0(str_to_sentence(Y), " against continuous variables")}
    
# Y vs. Numeric
  ggplot(datExp %>%
           dplyr::select(varExp) %>%
           dplyr::select_if(is.numeric) %>%
           tidyr::gather(variable,value,2:ncol(.)) %>%
           dplyr::arrange(!!ensym(Y)) %>%
           dplyr::filter(!variable %in% c("join"))
         , aes(value,!!ensym(Y))
         ) +
    geom_point(alpha = 0.5) +
    facet_wrap(~variable, scales = "free") +
    theme(axis.text.x=element_text(angle=90, vjust=0.5))

```

---

```{r llCollinearity{{thisGroup}}, fig.height = 9, fig.cap = "Exploring collinearity amongst variables"}

# Homogeneity of variance
# check modResid - plot modResid vs. fitted values

# Normally distributed
# check distribution of modResid - they should be normally distributed

# Collinearity among the covariates
  ggpairs(datExp %>%
            dplyr::select(varExp) %>%
            dplyr::select_if(function(x) length(levels(as.factor(x))) < 14|is.numeric(x))
          )

```

---

```{r llModel{{thisGroup}}}

# variables to model
  varMod <- c(Y
              , "Taxa"
              , "Year"
              , "IBRA_SUB_C"
              , "listLength"
              )

  medYear <- round(median(unique(datExp$Year)),0)
    
  datMod <- datExp %>%
    # TESTING START
    # dplyr::inner_join(datExp %>%
    #                     dplyr::group_by(!!ensym(interest)) %>%
    #                     dplyr::count(Taxa) %>%
    #                     dplyr::slice(sample(1:nrow(.))) %>%
    #                     dplyr::filter(row_number() < 0.25*nrow(.)) %>%
    #                     dplyr::ungroup() %>%
    #                     dplyr::select(-n)
    #                   ) %>%
    # TESTING FINISH
    dplyr::select(varMod) %>%
    dplyr::mutate(time = Year - medYear)
    

#-----Model------

  # If the model has not already been run, run it and save the result to the R directory
  outFile <- paste0(outDir,"/llMod",thisGroup,".rds")
  
  if(file.exists(outFile)){
    
    mod <- read_rds(outFile)
    
  } else {
    
    mod <-
    stan_glmer(data = datMod
               
               # Normal
               #, formula = as.formula(paste0(Y, " ~ time*",interest," + (time|Taxa)"))
               
               # Binomial
               , formula = as.formula(if_else(n_distinct(datMod$Taxa) > 1
                                              , paste0("cbind(p,1-p) ~ time * listLength * Taxa + (1|IBRA_SUB_C)")
                                              , paste0("cbind(p,1-p) ~ time * listLength + (1|IBRA_SUB_C)")
                                              )
                                      )
               , family = binomial()
               
               # Beta
               # , formula = as.formula(paste0(Y, " ~ time*",interest," + (time|Taxa)"))
               # , family = mgcv::betar()
               
               # Options
               , adapt_delta = 0.99
               , chains = doChains
               , iter = doIter
               
               )
  
    write_rds(mod, outFile)
  
  }
  
  
#-------Prediction------
  
  useLL <- datMod %>%
    dplyr::count(Year,IBRA_SUB_C,listLength) %>%
    dplyr::group_by(IBRA_SUB_C) %>%
    dplyr::summarise(listLength = median(listLength)) %>%
    dplyr::pull(listLength) %>%
    quantile(probs = c(0.1,0.5,0.9))
  
  predRuns <- 1
  
  modPred <- as_tibble(mod$data) %>%
    dplyr::count(time,Taxa) %>%
    dplyr::mutate(join = 1) %>%
    dplyr::left_join(tibble::enframe(useLL,name = "quantile", value = "listLength") %>%
                       dplyr::mutate(join = 1) %>%
                       dplyr::left_join(tibble(predictRun = seq(1,predRuns,1), join = 1))
                     ) %>%
    dplyr::mutate(col = row.names(.)
                  , p = 0
                  ) %>%
    dplyr::left_join(as_tibble(posterior_predict(mod
                                                 , newdata = .
                                                 , re.form = NA
                                                 )
                               ) %>%
                       tibble::rownames_to_column(var = "row") %>%
                       tidyr::gather(col,value,2:ncol(.))
                     ) %>%
    (function(x) dplyr::bind_cols(x %>% dplyr::select(-value),value = as.numeric(x$value))) %>%
    dplyr::mutate(Year = medYear + time)

  # summarise the results
  modRes <- modPred %>%
    dplyr::group_by(quantile,Year,Taxa,listLength) %>%
    dplyr::summarise(n = n()
                     , nCheck = nrow(as_tibble(mod))
                     , modMean = mean(value)
                     , modMedian = quantile(value, 0.5)
                     , modci90lo = quantile(value, 0.05)
                     , modci90up = quantile(value, 0.95)
                     , text = paste0(round(modMedian,2)," (",round(modci90lo,2)," to ",round(modci90up,2),")")
                     ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate_if(is.numeric,round,2) %>%
    dplyr::mutate(legend = paste0("List length of ",listLength,": ",quantile," quantile")
                  , legend = fct_inorder(legend,listLength)
                  )
  
  # modRes <- modPred %>%
  #   dplyr::group_by(Year,name,Taxa) %>%
  #   dplyr::summarise(n = n()
  #                    , nCheck = nrow(as_tibble(mod))
  #                    , prop = sum(value > 0)/n
  #                    ) %>%
  #   dplyr::ungroup() %>%
  #   dplyr::mutate_if(is.numeric,round,2) 
  
  
#------Residuals--------
  
  modResid <- tibble(resid = residuals(mod)) %>%
    dplyr::bind_cols(datMod)
  
#-------Difference------
  
  modDiff <- as_tibble(mod) %>%
    dplyr::mutate(row = row_number()) %>%
    dplyr::select(row, everything()) %>%
    dplyr::select_if(grepl("time|row", names(.))) %>%
    dplyr::select_if(!grepl("\\[",names(.))) %>%
    dplyr::mutate(`time:TaxaDummy` = 0) %>%
    tidyr::gather(key,value,grep("Taxa",names(.))) %>%
    dplyr::mutate(parameter = str_extract(key,".*:Taxa")
                  , Taxa = str_extract(key,":Taxa.*")
                  , Taxa = gsub(":Taxa","",Taxa)
                  ) %>%
    dplyr::select(-key) %>%
    tidyr::spread(parameter,value) %>%
    tidyr::gather(parameter,value,-row,-Taxa) %>%
    dplyr::group_by(row,Taxa) %>%
    dplyr::summarise(n = n()
                  , rawTime = sum(value, na.rm=TRUE)
                  , Time = if_else(mod$family$link %in% c("logit"), exp(rawTime),rawTime)
                  ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(Taxa = if_else(Taxa == "Dummy",setdiff(unique(datMod$Taxa),unique(.$Taxa)),Taxa)) %>%
    dplyr::filter(Taxa != "Dummy") %>%
    dplyr::left_join(luTaxSimple)
  
  threshold <- if_else(mod$family$link %in% c("logit"), 1,0)

  modDiffRes <- modDiff %>%
    dplyr::group_by(Taxa) %>%
    dplyr::summarise(n = n()
                     , nCheck = nrow(as_tibble(mod))
                     , modMean = mean(Time)
                     , modMedian = quantile(Time,0.5)
                     , modci90lo = quantile(Time, 0.05)
                     , modci90up = quantile(Time, 0.95)
                     , increasing = round(100*sum(Time > threshold)/n,0)
                     , decreasing = round(100*sum(Time < threshold)/n,0)
                     , text = paste0(round(modMedian,4)," (",round(modci90lo,4)," to ",round(modci90up,4),")")
                     ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate_if(is.numeric,round,4) %>%
    dplyr::left_join(luTaxSimple) %>%
    dplyr::mutate(Taxa = fct_reorder(Taxa,desc(modMedian)))
  
```

### Diagnostics

#### MCMC evaluation

Two common checks were used to evaluate the Monte Carlo Markov-chain samples: trace plots and $\hat{R}$ values.

Figure \@ref(fig:llModTrace{{thisGroup}}) shows trace plots for each of the `r length(dimnames(as.array(mod))$chains)` chains. Each chain should be stable and well-mixed (all chains centred around the same value) showing 'random noise' around the parameter value with no step change or ll evident.

Figure \@ref(fig:llModRhat{{thisGroup}}) shows the $\hat{R}$ values. At convergence $\hat{R}$ is one.

---

```{r llModTrace{{thisGroup}}, fig.cap = "Trace plots: stable, well-mixed chains indicate convergence"}

  stan_trace(mod)

```

---

```{r llModRhat{{thisGroup}}, fig.cap = "$\\hat{R}$ values close to one indicate convergence"}

  plot(mod, "rhat_hist")

```

---

#### Model fit

Given the MCMC evaluation shows no reason for concern, assuming the model was specified adequately, the model runs should generate data similar to the observed data.

Figure \@ref(fig:llModFit{{thisGroup}}) shows a comparison of the observed data (dark line) with a sample of 50 of the the model runs (light lines). The model runs should largely follow the shape of the observed data.

Figure \@ref(fig:llMod2d{{thisGroup}}) shows how the mean and standard deviation of the observed data (dark dot) compares with a sample of 50 of the model runs (light dots). The model runs should be centred on the observed data.

```{r llModFit{{thisGroup}}, fig.cap = "Random selection of model runs (light blue) and actual values (dark blue)"}
  
  # Model fit
  a <- pp_check(mod) + coord_cartesian(xlim = c(min(mod$fitted.values),quantile(mod$fitted.values,probs=0.1))) + labs(title = "min-quantile(0.1)")
  b <- pp_check(mod) + coord_cartesian(xlim = c(min(mod$fitted.values),quantile(mod$fitted.values,probs=0.5))) + labs(title = "min-quantile(0.5)")
  c <- pp_check(mod) + coord_cartesian(xlim = c(quantile(mod$fitted.values,probs=0.5),max(mod$fitted.values))) + labs(title = "quantile(0.5)-max")
  d <- pp_check(mod) + labs(title = "min-max pred")
  grid.arrange(a,b,c,d)

```

---

```{r llMod2d{{thisGroup}}, fig.cap = "Plot of model run mean and standard deviation (light blue dots) against the actual those values from the data (dark blue dots"}

   pp_check(mod, plotfun = "stat_2d", stat = c("mean", "sd"))

```

---

#### Residuals

In regression-type models, verification of homogeneity should be done by plotting residuals vs. fitted values [@RN4330]. Figure \@ref(fig:llModYVsResid{{thisGroup}}) shows `r Y` versus the model residuals and Figure \@ref(fig:llModContVsResid{{thisGroup}}) shows any continuous variable versus the model residuals and Figure \@ref(fig:llModDiscVsResid{{thisGroup}})

---

```{r llModYVsResid{{thisGroup}}, fig.cap = paste0(Y, " vs residuals")}

  # Y vs. residuals
  ggplot(modResid, aes(!!ensym(Y),resid)) +
    geom_point(size = 2) +
    geom_hline(aes(yintercept = 0), linetype = 2, colour = "red") +
    facet_wrap(~Taxa) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) %>%
    scale_colour_viridis_d(end=0.9)
  
```

---

```{r llModContVsResid{{thisGroup}}, fig.cap = "Continuous explanatory variables vs residuals"}
  
  # Time vs. residuals
  ggplot(modResid %>%
           dplyr::select_if(is.numeric) %>%
           tidyr::gather(variable,value,2:ncol(.))
         , aes(value,resid)
         ) +
    geom_point(size = 2
              #, alpha=0.5
              #, position=position_jitter(width=0.3,height=0.2)
              ) +
    geom_hline(aes(yintercept = 0), linetype = 2, colour = "red") +
    facet_wrap(~variable, scales = "free_x") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
          #, strip.text.x = element_text(angle = 90)
          ) +
    scale_colour_viridis_d()

```

---

```{r llModDiscVsResid{{thisGroup}}, fig.cap = "Discrete explanatory variables vs residuals"}
  
  ggplot(modResid %>%
           dplyr::mutate(resid = as.character(resid)) %>%
           dplyr::mutate_if(is.factor,as.character) %>%
           dplyr::select_if(is.character) %>%
           dplyr::select(resid,everything()) %>%
           dplyr::mutate(resid = as.numeric(resid)) %>%
           tidyr::gather(variable,value,2:ncol(.))
         , aes(value,resid)
         ) +
    geom_boxplot() +
    geom_hline(aes(yintercept = 0), linetype = 2, colour = "red") +
    facet_wrap(~variable, scales = "free") +
    theme(axis.text.x=element_text(angle=90, vjust=0.5))

```

---

### Results

Figure \@ref(fig:llModPred{{thisGroup}}) plots the model results against the original data. Figure \@ref(fig:llModTrend{{thisGroup}}) shows the distribution of credible values of slope for each `r interest`. Increasing list length is indicated by slope greater than zero while decreasing list length is indicated by slope less than zero.

Based on these results Table \@ref(tab:llModResults{{thisGroup}}) shows the likelihood that each `r interest` is decreasing or increasing.

---

```{r llModPred{{thisGroup}}, fig.height = 7, fig.cap = "Model result and 90% credible intervals (line and shading) plotted with original data points"}

  ggplot(data = datMod
         , aes(x = Year
               , y = p
               )
         ) +
    geom_jitter(width = 0.1
                , height = 0.01
                , shape = "."
                , size = 2
                ) +
    geom_line(data = modRes
              , aes(y = modMedian
                    , colour = quantile
                    )
              ) +
    geom_ribbon(data = modRes %>% dplyr::rename(p = modMedian)
                , aes(x = Year
                      , ymin=modci90lo
                      , ymax=modci90up
                      , fill = quantile
                      , colour = NULL
                      )
                , alpha = 0.3
                ) +
    facet_grid(legend~Taxa
               , labeller = labeller(legend = label_wrap_gen(10))
               ) +
    theme(axis.text.x = element_text(angle=90, hjust=0)
          , strip.text.y = element_text(angle = 0)
          #, legend.position = "none"
          )

```

---

```{r llModTrend{{thisGroup}}, fig.height = 7, fig.cap = paste0("Distribution of credible values for slope")}

  xinter <- if_else(mod$family$link %in% c("logit"),1,0)

  ggplot(modDiff %>%
           dplyr::mutate(Taxa = fct_reorder(Taxa,desc(Time)))
         , aes(Time,Taxa,fill = 0.5-abs(0.5-..ecdf..))
         ) +
    stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE, panel_scaling = FALSE) +
    geom_vline(aes(xintercept = xinter), colour = "red", linetype = 2) +
    scale_fill_viridis_c(name = "Probability") +
    labs(subtitle = if_else(mod$family$link %in% c("logit")
                              , paste0("Values above one indicate increasing likelihood of presence on a list of median length")
                              , paste0("Values above zero indicate increasing likelihood of presence on a list of median length")
                              )
         , x = "Change per year"
         )

```

---

```{r llModResults{{thisGroup}}}

  kable(modDiffRes %>%
          dplyr::select(Taxa
                        , `Median and 90% credible estimate for effect of year` = text
                        , `Likelihood of decreasing (%)` = decreasing
                        , `Likelihood of increasing (%)` = increasing
                        ) %>%
          dplyr::arrange(desc(Taxa))
        , caption = paste0("The effect of year on the likelihood of each taxa in ", thisGroup, " appearing on a list")
        ) %>%
    kable_styling("striped") %>%
    scroll_box(width = "100%")

```

